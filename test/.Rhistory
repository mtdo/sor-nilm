# Sample other z_{t,k} recursively using F and P
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
}
warnings()
#FFBS
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 3
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 10, (Kdag - 1)) # State matrix
Z[sample(1:10, round(0.3*10)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.3),rnorm(5,7,0.3)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
k
i
#FFBS
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 3
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 10, (Kdag - 1)) # State matrix
Z[sample(1:10, round(0.3*10)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.3),rnorm(5,7,0.3)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
k=1
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
P
pi_P <- matrix(c(P[2,1]/(1-P[1,1]+P[1,2]),1-P[2,1]/(1-P[1,1]+P[1,2])),byrow = T,nrow=1)
D <- matrix(0,nrow=length(Y),ncol=2)
D
Z_k_zero <- Z
View(Z_k_zero)
Z_k_zero[,k] <- 0
View(Z_k_zero)
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
D
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
View(Z_k_one)
View(D)
FF <- matrix(0,nrow=length(Y),ncol=2)
FF
FF[1,] <- pi_P * D[1,]
FF
FF[1,] <- pi_P * D[1,]
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
FF
p1 <- FF[length(Y),1]/(FF[length(Y),0]+FF[length(Y),1])
p1
FF[length(Y),1]
(Y-Z_k_zero%*%t(theta))^2
#FFBS
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 4
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 10, (Kdag - 1)) # State matrix
Z[sample(1:10, round(0.3*10)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.3),rnorm(5,7,0.3)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
k=1
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
#Stationary distribution of P as an initialization of p(z_{t,k} | Y_0,...)
pi_P <- matrix(c(P[2,1]/(1-P[1,1]+P[1,2]),1-P[2,1]/(1-P[1,1]+P[1,2])),byrow = T,nrow=1)
# Matrix D (Length(Y) x 2) containing f(Y_t | z_{t,k}=i), i=0,1
D <- matrix(0,nrow=length(Y),ncol=2)
Z_k_zero <- Z
Z_k_zero[,k] <- 0
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
D
FF <- matrix(0,nrow=length(Y),ncol=2)
FF[1,] <- pi_P * D[1,]
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
FF
p1 <- FF[length(Y),1]/(FF[length(Y),0]+FF[length(Y),1])
FF[length(Y),1]/(FF[length(Y),0]+FF[length(Y),1])
FF[length(Y),0]+FF[length(Y),1]
FF[length(Y),1]
FF[length(Y),0]
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
p1
Z[length(Y),k] <- rbinom(1,1,p1)
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
Z
#FFBS
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 4
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 10, (Kdag - 1)) # State matrix
Z[sample(1:10, round(0.3*10)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.3),rnorm(5,7,0.3)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
for (k in 1:2) {
#Transition matrix of chain k
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
#Stationary distribution of P as an initialization of p(z_{t,k} | Y_0,...)
pi_P <- matrix(c(P[2,1]/(1-P[1,1]+P[1,2]),1-P[2,1]/(1-P[1,1]+P[1,2])),byrow = T,nrow=1)
# Matrix D (Length(Y) x 2) containing f(Y_t | z_{t,k}=i), i=0,1
D <- matrix(0,nrow=length(Y),ncol=2)
Z_k_zero <- Z
Z_k_zero[,k] <- 0
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
# Matrix F (length(Y) x 2) for storing p(z_{t,k}= i | Y_t,...), i=0,1
FF <- matrix(0,nrow=length(Y),ncol=2)
FF[1,] <- pi_P * D[1,]
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
# Sample z_{length(Y),k} from last row of FF
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
Z[length(Y),k] <- rbinom(1,1,p1)
# Sample other z_{t,k} recursively using F and P
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
}
Z%*%t(theta)
Z
#FFBS
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 4
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 10, (Kdag - 1)) # State matrix
Z[sample(1:10, round(0.3*10)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.3),rnorm(5,7,0.3)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
for (k in 1:2) {
#Transition matrix of chain k
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
#Stationary distribution of P as an initialization of p(z_{t,k} | Y_0,...)
pi_P <- matrix(c(P[2,1]/(1-P[1,1]+P[1,2]),1-P[2,1]/(1-P[1,1]+P[1,2])),byrow = T,nrow=1)
# Matrix D (Length(Y) x 2) containing f(Y_t | z_{t,k}=i), i=0,1
D <- matrix(0,nrow=length(Y),ncol=2)
Z_k_zero <- Z
Z_k_zero[,k] <- 0
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
# Matrix F (length(Y) x 2) for storing p(z_{t,k}= i | Y_t,...), i=0,1
FF <- matrix(0,nrow=length(Y),ncol=2)
FF[1,] <- pi_P * D[1,]
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
# Sample z_{length(Y),k} from last row of FF
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
Z[length(Y),k] <- rbinom(1,1,p1)
# Sample other z_{t,k} recursively using F and P
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
}
#FFBS
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 4
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 10, (Kdag - 1)) # State matrix
Z[sample(1:10, round(0.3*10)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.3),rnorm(5,7,0.3)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
Z
o.mu
k=1
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
P
pi_P <- matrix(c(P[2,1]/(1-P[1,1]+P[1,2]),1-P[2,1]/(1-P[1,1]+P[1,2])),byrow = T,nrow=1)
pi_P
D <- matrix(0,nrow=length(Y),ncol=2)
D
Z_k_zero <- Z
Z_k_zero[,k] <- 0
Z_k_zero
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
D
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
D
FF <- matrix(0,nrow=length(Y),ncol=2)
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
FF
FF[1,] <- pi_P * D[1,]
FF
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
FF
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
p1
Z[length(Y),k] <- rbinom(1,1,p1)
Z
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
FF
Z
k=2
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
P
pi_P <- matrix(c(P[2,1]/(1-P[1,1]+P[1,2]),1-P[2,1]/(1-P[1,1]+P[1,2])),byrow = T,nrow=1)
pi_P
D <- matrix(0,nrow=length(Y),ncol=2)
View(D)
Z_k_zero <- Z
Z_k_zero[,k] <- 0
View(Z_k_zero)
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
View(D)
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
View(Z_k_one)
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
View(D)
FF <- matrix(0,nrow=length(Y),ncol=2)
FF[1,] <- pi_P * D[1,]
View(FF)
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
View(FF)
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
Z[length(Y),k] <- rbinom(1,1,p1)
Z
FF
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
View(Z)
Z
Y
Z%*%theta
Z%*%t(theta)
theta
View(Z)
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
Z
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
View(FF)
View(P)
View(pi_P)
eig(P)
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
pi_P <- solve(matrix(c(1-P[1,1],-P[2,1],1,1),byrow = T,nrow=2),c(0,1))
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
plot(Y)
plot(Y,type = "l")
plot(Z%*%t(theta),type = "l",col="red")
plot(Y,type = "l")
par(new=T)
plot(Z%*%t(theta),type = "l",col="red")
Z
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
Z
Z <- matrix(1, 20, (Kdag - 1)) # State matrix
Z
Z[sample(1:20, round(0.3*20)),2] <- 0 # Add some zeros
Z
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Z
Y <- c(rnorm(5,5,0.2),rnorm(5,7,0.2),rnorm(5,13,0.2),rnorm(5,5,0.2)) # Observed data
Y
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
theta
o.mu
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
P
pi_P <- solve(matrix(c(1-P[1,1],-P[2,1],1,1),byrow = T,nrow=2),c(0,1))
pi_P
D <- matrix(0,nrow=length(Y),ncol=2)
Z_k_zero <- Z
Z_k_zero[,k] <- 0
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
D
FF <- matrix(0,nrow=length(Y),ncol=2)
FF[1,] <- pi_P * D[1,]
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
FF
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
Z[length(Y),k] <- rbinom(1,1,p1)
p1
Z
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
Z
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
View(P)
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/FFBS.R')
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 4
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 20, (Kdag - 1)) # State matrix
Z[sample(1:20, round(0.3*20)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.2),rnorm(5,7,0.2),rnorm(5,13,0.2),rnorm(5,5,0.2)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
for (k in 1:2) {
#Transition matrix of chain k
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
#Stationary distribution of P as an initialization of p(z_{t,k} | Y_0,...)
pi_P <- solve(matrix(c(1-P[1,1],-P[2,1],1,1),byrow = T,nrow=2),c(0,1))
# Matrix D (Length(Y) x 2) containing f(Y_t | z_{t,k}=i), i=0,1
D <- matrix(0,nrow=length(Y),ncol=2)
Z_k_zero <- Z
Z_k_zero[,k] <- 0
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
# Matrix F (length(Y) x 2) for storing p(z_{t,k}= i | Y_t,...), i=0,1
FF <- matrix(0,nrow=length(Y),ncol=2)
FF[1,] <- pi_P * D[1,]
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
# Sample z_{length(Y),k} from last row of FF
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
Z[length(Y),k] <- rbinom(1,1,p1)
# Sample other z_{t,k} recursively using F and P
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
}
plot(Y,type="l")
par(new=T)
plot(Z%*%t(theta),type="l",col="red")
plot(1:20,Y,1:20,Z%*%t(theta),type=c("l","l"),col=c("black","red"))
plot(1:20,Y,Z%*%t(theta),type=c("l","l"),col=c("black","red"))
plot(1:20,c(Y,Z%*%t(theta)),type=c("l","l"),col=c("black","red"))
plot(c(1:20,1:20),c(Y,Z%*%t(theta)),type=c("l","l"),col=c("black","red"))
plot(1:20,Y,type="l")
lines(1:20,Z%*%t(theta),col="red")
theta <- matrix(c(5,7,2), 1, Kdag)
#FFBS
alpha <- 1.5 # mu, beta distribution, strength parameter of IBP
gamma <- 1.5 # b, beta distribution
delta <- 1 # b, beta distribution
mu_theta <- 4
sigma_theta <- 0.3
sigma_epsilon <- 0.4
# Parameters
Kdag  <- 3 # Number of active appliances + 1
Z <- matrix(1, 20, (Kdag - 1)) # State matrix
Z[sample(1:20, round(0.3*20)),2] <- 0 # Add some zeros
Z <- cbind(Z, matrix(0, nrow(Z), 1)) # Add empty column
Y <- c(rnorm(5,5,0.2),rnorm(5,7,0.2),rnorm(5,13,0.2),rnorm(5,5,0.2)) # Observed data
o.mu <- matrix(rbeta(Kdag, alpha/Kdag, 1), 1, Kdag) # State transition probability
o.mu <- o.mu[order(o.mu, decreasing = T)] # Order state transition probabilities
b <- matrix(rbeta(Kdag, gamma, delta), 1, Kdag) # State transition probability
#theta <- matrix(rnorm(Kdag, mu_theta, sigma_theta), 1, Kdag) # State levels
theta <- matrix(c(5,7,2), 1, Kdag)
k=1
for (k in 1:2) {
#Transition matrix of chain k
P <- matrix(c(1-o.mu[k],o.mu[k],1-b[k],b[k]),byrow = T,nrow=2)
#Stationary distribution of P as an initialization of p(z_{t,k} | Y_0,...)
pi_P <- solve(matrix(c(1-P[1,1],-P[2,1],1,1),byrow = T,nrow=2),c(0,1))
# Matrix D (Length(Y) x 2) containing f(Y_t | z_{t,k}=i), i=0,1
D <- matrix(0,nrow=length(Y),ncol=2)
Z_k_zero <- Z
Z_k_zero[,k] <- 0
D[,1] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_zero%*%t(theta))^2/(2*sigma_epsilon^2))
Z_k_one <- Z_k_zero
Z_k_one[,k] <- 1
D[,2] <- 1/sqrt(2*sigma_epsilon^2*pi)*exp(-(Y-Z_k_one%*%t(theta))^2/(2*sigma_epsilon^2))
# Matrix F (length(Y) x 2) for storing p(z_{t,k}= i | Y_t,...), i=0,1
FF <- matrix(0,nrow=length(Y),ncol=2)
FF[1,] <- pi_P * D[1,]
for (i in 2:length(Y)){
FF[i,] <- (t(FF[i-1,]) %*% P) * D[i,]
}
# Sample z_{length(Y),k} from last row of FF
p1 <- FF[length(Y),2]/(FF[length(Y),1]+FF[length(Y),2])
Z[length(Y),k] <- rbinom(1,1,p1)
# Sample other z_{t,k} recursively using F and P
for (i in 1:(length(Y)-1)){
props <- FF[length(Y)-i,]*t(P[,Z[length(Y),k]+1])
p1 <- props[2]/sum(props)
Z[length(Y)-i,k] <- rbinom(1,1,p1)
}
}
plot(1:20,Y,type = "l")
lines(1:20,Z%*%t(theta),col="red")
lines(1:20,theta(1)*Z[,1],col="green")
lines(1:20,theta[1]*Z[,1],col="green")
lines(1:20,theta[2]*Z[,2],col="blue")
a <- c(0.5,0.3,0.1)
B <- matrix(c(1,0,1,0,0,1,1,0,0),byrow=T,ncol=3)
sum(B)
sum(B[a])
B[a]
B[,a]
B[a,]
colSums(B)
min(a[which(colSums(B)>0)])
a=c(0.3,0.1,0.2)
min(a[which(colSums(B)>0)])
which(colSums(B)>0)
1 & 0
c(1,2)*c(1,2)*c(1,2)
0|1
0||1
runif(3,0,0.5)
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/sor-nilm/test/test.R')
setwd("~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/sor-nilm/test")
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/sor-nilm/test/test.R')
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/sor-nilm/test/test.R')
source('~/Documents/Kouluhommat/Operaatiotutkimuksen projektityöseminaari/sor-nilm/test/test.R')
